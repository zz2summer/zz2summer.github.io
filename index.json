[{"categories":["LeetCode"],"content":"剑指 Offer 16. 数值的整数次方实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 版权声明：本文为博主 渣渣的夏天 的原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:0:0","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 16. 数值的整数次方 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n^）。不得使用库函数，同时不需要考虑大数问题。 示例 1： 输入：x = 2.00000, n = 10 输出：1024.00000 示例 2： 输入：x = 2.10000, n = 3 输出：9.26100 示例 3： 输入：x = 2.00000, n = -2 输出：0.25000 解释：2^-2 = (1/2)^2 = 1/4 = 0.25 提示： -100.0 \u003c x \u003c 100.0 -2^31^ \u003c= n \u003c= 2^31^-1 -10^4^ \u003c= x^n^ \u003c= 10^4^ 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:1:0","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"二、解题思路  首先朴素的菜鸟方法，正数用 for 循环累乘 n 个 x，负数则先将 x 取倒数再将 n 取绝对值，考虑特殊情况 x=0。然后不出意外的话就是超时了。 ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:2:0","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"1.递归  观察 x → x^2^ → x^4^ → x^16^ → x^32^ → x^64^ ，所以其实计算 x^64^ 时很多地方没必要再次逐个计算了。首先对于负数就是计算 x^-n^ 的倒数。正数就是不断计算 x^n/2^ ，如果 n 为奇数还需要再乘以 x。 ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:2:1","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"2.迭代  又是数学知识，首先整数的二进制拆分为：n = 2^i0^ + 2^i1^ + …… + 2^ik^，那么 x^n^ = x^m0^ * x^m1^ * …… * x^mk^ ，其中 mk = 2^ik^ 。如果 x 二进制的第 k 位为 1 ，则需要纳入贡献。 注：本题计算方法又称快速幂方法。 ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:2:2","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"三、代码 ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:3:0","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"1.递归 class Solution { public double myPow(double x, int n) { long N = n; return N \u003e= 0 ? quickMul(x, N) : 1/quickMul(x, -N); } public double quickMul(double x, long N){ if(N == 0){ return 1.0; } double y = quickMul(x, N/2); return N%2==0 ? y*y : y*y*x; } } ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:3:1","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"2.迭代 class Solution { public double myPow(double x, int n) { long N = n; return N \u003e= 0 ? quickMul(x, N) : 1/quickMul(x, -N); } public double quickMul(double x, long N){ double ans = 1.0; // 记录每个项 double x_con = x; while(N \u003e 0){ // 最后一位为1，纳入贡献 if(N % 2 == 1){ ans *= x_con; } x_con *= x_con; // 不断右移 N /= 2; } return ans; } } ","date":"2022-07-05 22:43:35","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/:3:2","tags":["LeetCode","Java","数值整数次方","快速幂"],"title":"LeetCode 之 剑指 Offer 16. 数值的整数次方（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9java/"},{"categories":["LeetCode"],"content":"剑指 Offer 15. 二进制中1的个数编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。提示：请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:0:0","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 15. 二进制中1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：n = 128 (控制台输入 00000000000000000000000010000000) 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3） 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： 输入必须是长度为 32 的 二进制串 。 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:1:0","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"二、解题思路  这道题最直接的思路是原数直接短除 2 按照十进制转二进制的方法去计算 1 的个数，但是呢，它题目是可能有负数的，负数转换就比较复杂了。另一方面题目是考虑除法效率比位运算低很多。 ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:2:0","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"1.循环检查二进制  输入是 32 位二进制，当其与只包含一个 1 的 32 位二进制串进行 \u0026 运算时可以得知后者 1 所在位置在前者该位置处是 0 还是 1。其他位置进行 \u0026 运算会全是 0，如果结果是 0 表示输入的该位置是 0 ，如果结果是 1 ，则表示输入的该位置是 1。 ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:2:1","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"2.直接计算1个数  这里就要用到一些特殊的数学知识，感觉得靠积累了。n \u0026 (n-1) 会将 n 最右边的 1 变为 0。比如：1100 \u0026 （1100-1）= 1100 \u0026 1011 = 1000，这里我们可以理解 n-1 后就相当于把最右边 1 的右边的 0 全部变为 1 ，把最右边的 1 变为 0，这样再与原数进行 \u0026 运算，那本来最右边 1 的右边肯定全是 0，而最右边的 1 已经变成 0，这不就是直接把最右边的 1 及更右边的数全部变成 0 了。 ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:2:2","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"三、代码 ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:3:0","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"1.循环检查二进制 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int ret = 0; for(int i=0; i\u003c32; i++){ if((n \u0026 (1 \u003c\u003c i)) != 0){ ret++; } } return ret; } } ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:3:1","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"2.直接计算1个数 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int ret = 0; while(n!=0){ ret++; n \u0026= n-1; } return ret; } } ","date":"2022-07-05 22:37:29","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/:3:2","tags":["LeetCode","Java","二进制"],"title":"LeetCode 之 剑指 Offer 15. 二进制中1的个数（Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 14- II. 剪绳子 II （Java） ，给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u003e1并且m\u003e1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:0:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 14- II. 剪绳子 II 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u003e1并且m\u003e1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 \u003c= n \u003c= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:1:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"二、解题思路  这道题主要是将 n 的范围扩大了，然后结果可能越界需要取模，进而代码方面会有些改动。 ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:2:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"1.动态规划  方法是一样的，但是需要用到大数操作——java.math.BigInteger，初始化、相乘、取最大值和最后的取余这四处地方需要修改。（此时的 Math.max 已不适用与取模后做比较了） ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:2:1","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"2.贪婪算法  思路同原题，主要是在求 3^n^ 时要不断的取余防止溢出。 ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:2:2","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"三、代码 ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:3:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"3.1 动态规划 import java.math.BigInteger; class Solution { public int cuttingRope(int n) { // 3.1 DP if(n\u003c2){ return 0; } if(n==2){ return 1; } if(n==3){ return 2; } // n=2,3 具有特殊性，单独时必须至少剪一刀，所以f(2)=1,f(3)=2，但是放到剪的两侧时其实最大为2,3，所以动态公式从 4 开始，f(n)=Max(f(i)*f(n-i)) (n\u003e3,i\u003c=n/2) BigInteger[] m = new BigInteger[n+1]; for(int i=0; i\u003cn+1; i++){ m[i] = BigInteger.valueOf(1); } m[2] = BigInteger.valueOf(2); m[3] = BigInteger.valueOf(3); for(int i=4; i\u003cn+1; i++){ for(int j=1; j\u003c=i/2; j++){ // m[i] 缓存遍历 j 时前面所有的剪法的最大值，直到最后为所有分法的最大值，Math.max已不适用 m[i] = m[i].max(m[j].multiply(m[i-j])); } } return m[n].mod(BigInteger.valueOf(1000000007)).intValue(); } } ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:3:1","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"3.2 贪婪算法 class Solution { public int cuttingRope(int n) { // 3.2 贪婪 if(n\u003c2){ return 0; } if(n==2){ return 1; } if(n==3){ return 2; } long p = 1000000007; long res = 1; while(n\u003e4){ res = res * 3 % p; n -= 3; } return (int)(res * n % p); } } ","date":"2022-03-15 10:07:22","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/:3:2","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  II. 剪绳子 II （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii-java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 14- I. 剪绳子 （Java） ，给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u003e1并且m\u003e1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:0:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 14- I. 剪绳子 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u003e1并且m\u003e1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 \u003c= n \u003c= 58 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:1:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"二、解题思路 ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:2:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"1.动态规划  对于剪绳子，可以直接考虑将其剪为两段——i,n-i → f(n) = Max(f(i)*f(n-i))，其中 i\u003c=n/2 \u0026\u0026 i\u003e3，这个 i\u003e3 就很巧妙。当 i\u003c2 时 ，f(i)=0，然后 f(2)=1,f(3)=2，应为 m\u003e1即最少要剪一刀。但是其实到了后面剪成两段时，如果出现 i=2/3，可以直接不剪，这样这段绳子在相乘时可以直接取 2/3。具体代码见解法3.1  网上还有种解法是说将绳子先剪一段 i ，然后剩下的 n-i 可以选择剪或者不剪，这样动规公式就是 f(n)=Max(i*(n-i), i*m[n-i])。但是其实细想至少按照动规思路来说，这个公式肯定是不对的。因为右侧可以剪或者不剪，那左侧自然也可以剪或者不剪，即动规应该是 f(n)=Max(i*(n-i), i*m[n-i], m[i]*(n-i), m[i]*m[n-i])。当然，那么做答案是对的，具体代码见解法3.2 ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:2:1","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"2.贪婪算法  利用贪婪算法得在数学上证明成立，一般感觉不好想到。  本题中是说在 n\u003e4 时，先尽可能剪成 3 最后得到的累乘最大。这时剩下的长度可能为 0,1,2，如果为 0，这时正好不用管；如果为 1，这时可以从前面取一个 3，组成 2*2 更合适（3*1 \u003c 2*2）；如果最后为 2，那也不用管。所以最终的答案就是 2 和 3 分别剪了多少段。 ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:2:2","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"三、代码 ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:3:0","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"3.1 动态规划1 class Solution { public int cuttingRope(int n) { // 3.1 DP if(n\u003c2){ return 0; } if(n==2){ return 1; } if(n==3){ return 2; } // n=2,3 具有特殊性，单独时必须至少剪一刀，所以f(2)=1,f(3)=2，但是放到剪的两侧时其实最大为2,3，所以动态公式从 4 开始，f(n)=Max(f(i)*f(n-i)) (n\u003e3,i\u003c=n/2) int[] m = new int[n+1]; m[1] = 1; m[2] = 2; m[3] = 3; for(int i=4; i\u003cn+1; i++){ for(int j=1; j\u003c=i/2; j++){ // m[i] 缓存遍历 j 时前面所有的剪法的最大值，直到最后为所有分法的最大值 m[i] = Math.max(m[j]*m[i-j], m[i]); } } return m[n]; } } ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:3:1","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"3.2 动态规划2 class Solution { public int cuttingRope(int n) { // 3.2 DP if(n\u003c2){ return 0; } if(n==2){ return 1; } int[] m = new int[n+1]; m[1] = 1; m[2] = 1; for(int i=3; i\u003cn+1; i++){ for(int j=1; j\u003c=i/2; j++){ m[i] = Math.max(Math.max(j*(i-j), j*m[i-j]), m[i]); } } return m[n]; } } ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:3:2","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"3.3 贪婪算法 class Solution { public int cuttingRope(int n) { // 3.3 贪婪 if(n\u003c2){ return 0; } if(n==2){ return 1; } if(n==3){ return 2; } int t3 = n/3; if(n-t3*3==1){ t3--; } int t2 = (n-t3*3)/2; return (int)Math.pow(3,t3)*(int)Math.pow(2,t2); } } ","date":"2022-03-15 10:07:05","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/:3:3","tags":["LeetCode","Java","动态规划","贪婪","剪绳子"],"title":"LeetCode 之 剑指 Offer 14  I. 剪绳子 （Java） ","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90-java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 13. 机器人的运动范围（Java），地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-13 21:44:39","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/:0:0","tags":["LeetCode","Java","回溯","机器人运动范围"],"title":"LeetCode 之 剑指 Offer 13. 机器人的运动范围 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 13. 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1 输出：3 示例 2： 输入：m = 3, n = 1, k = 0 输出：1 提示： 1 \u003c= n,m \u003c= 100 0 \u003c= k \u003c= 20 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-13 21:44:39","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/:1:0","tags":["LeetCode","Java","回溯","机器人运动范围"],"title":"LeetCode 之 剑指 Offer 13. 机器人的运动范围 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/"},{"categories":["LeetCode"],"content":"二、解题思路  本题与上一题的矩阵路径很相似，感觉还简单些，就是起点是 [0, 0]，判断当前点能够进入然后再遍历四周的点，每次移动到四周点时再将该点作为起点即可。  三个细节：  一是判断进入函数，根据题目提示的 m, n 范围可以直接当做三位数取位数和计算 check 能够进入（不确定位数的则可以用 while 不断遍历截取）；  二是对于每次点向四周移动时应该有一个 visited 二维数组记录是否来过，如果来过就不再过去了；  三是计算总格子时是当前格子加上四周能够继续进入的格子数，所以在进入当前点时应该 ans++ ，然后再加上四周新进入的点。 ","date":"2022-03-13 21:44:39","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/:2:0","tags":["LeetCode","Java","回溯","机器人运动范围"],"title":"LeetCode 之 剑指 Offer 13. 机器人的运动范围 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/"},{"categories":["LeetCode"],"content":"三、代码 class Solution { public int movingCount(int m, int n, int k) { int ans = 0; int[][] visited = new int[m][n]; ans += move(0, 0, k, visited, m, n); return ans; } public boolean check(int i, int j, int k){ if(i%10 + i/10%10 + i/100 + j%10 + j/10%10 + j/100 \u003c= k){ return true; } return false; } public int move(int i, int j, int k, int[][] visited, int m, int n){ int ans = 0; if(check(i,j, k)){ visited[i][j]=1; ans++; int[][] directions = { {0,1}, {0,-1}, {-1,0}, {1,0}}; for(int[] dir : directions){ int newi = i+dir[0]; int newj = j+dir[1]; if(newi\u003e=0\u0026\u0026newi\u003cm \u0026\u0026 newj\u003e=0\u0026\u0026newj\u003cn \u0026\u0026 visited[newi][newj]==0){ ans += move(newi, newj, k, visited, m, n); } } } return ans; } } ","date":"2022-03-13 21:44:39","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/:3:0","tags":["LeetCode","Java","回溯","机器人运动范围"],"title":"LeetCode 之 剑指 Offer 13. 机器人的运动范围 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4-java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 12. 矩阵中的路径（Java），给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-06 14:20:27","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/:0:0","tags":["LeetCode","Java","回溯法","矩阵路径"],"title":"LeetCode 之 剑指 Offer 12. 矩阵中的路径 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 12. 矩阵中的路径 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-06 14:20:27","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/:1:0","tags":["LeetCode","Java","回溯法","矩阵路径"],"title":"LeetCode 之 剑指 Offer 12. 矩阵中的路径 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/"},{"categories":["LeetCode"],"content":"二、解题思路  对于二维数组的找路径问题，一般的建议是考虑使用回溯。遍历每个点，每次以当前点为起点，判断后续是否有继续的可能性，只需要考虑一次以当前点为起点的后续可能性并对每种可能性进行处理即可。  以本题为例，首先遍历二维数组中的每个点，两个 for 循环即可，之后对于每个点调用一个 check 的方法，判断以该点以起点后续有没有机会继续完成要求，也就是继续遍历完题目给定的 word ，如果有可能返回 true。调用后将  在 check 函数中，对于每个点，有四种选择的可能性——上下左右，所以会有一个 for 循环遍历四个方向，对于每个方向有三种可能性： 当前点不是当前需要满足的字符，直接返回 false； 当前点是当前需要满足的字符，并且该字符已经是给定 word 的最后一个字符，直接返回 true； 当前点是当前需要满足的字符，但是不是最后一个。此时将该点标记为已访问（防止接下来按四个方向遍历时又访问已经标记过的点），继续遍历上下左右四个方向，对于每个方向仍然调用 check 方法判断时候有可能继续完成剩余字符串的路径查找。 注意，不管此次是否找到结果，最后返回时都应当将 visited 标记为 false 表示该点未访问，因为每次的遍历都是从二维数组当前点为初始起点考虑的，也就是每次所有的点都应当是全新未访问的。 ","date":"2022-03-06 14:20:27","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/:2:0","tags":["LeetCode","Java","回溯法","矩阵路径"],"title":"LeetCode 之 剑指 Offer 12. 矩阵中的路径 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/"},{"categories":["LeetCode"],"content":"三、代码 class Solution { public boolean exist(char[][] board, String word) { int h = board.length, w = board[0].length; boolean[][] visited = new boolean[h][w]; for(int i=0; i\u003ch; i++){ for(int j=0; j\u003cw; j++){ boolean flag = check(board, visited, i, j, word, 0); if(flag){ return true; } } } return false; } public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k){ if(board[i][j] != s.charAt(k)){ return false; }else if(k==s.length()-1){ return true; } visited[i][j] = true; int[][] dirctions = { {0,1}, {0,-1},{1,0},{-1,0}}; boolean result = false; for(int[] dir : dirctions){ int newi = i+dir[0], newj = j+dir[1]; if(newi\u003e=0\u0026\u0026newi\u003cboard.length \u0026\u0026 newj\u003e=0\u0026\u0026newj\u003cboard[0].length){ if(!visited[newi][newj]){ boolean flag = check(board, visited, newi, newj, s, k+1); if(flag){ result = true; break; } } } } visited[i][j] = false; return result; } } ","date":"2022-03-06 14:20:27","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/:3:0","tags":["LeetCode","Java","回溯法","矩阵路径"],"title":"LeetCode 之 剑指 Offer 12. 矩阵中的路径 （Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84-java/"},{"categories":["LeetCode"],"content":"剑指 Offer 11. 旋转数组的最小数字，把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:37:23","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/:0:0","tags":["LeetCode","Java","旋转数组","最小数字"],"title":"LeetCode 之 剑指 Offer 11. 旋转数组的最小数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 11. 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2] 输出：1 示例 2： 输入：[2,2,2,0,1] 输出：0 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:37:23","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/:1:0","tags":["LeetCode","Java","旋转数组","最小数字"],"title":"LeetCode 之 剑指 Offer 11. 旋转数组的最小数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/"},{"categories":["LeetCode"],"content":"二、解题思路  对于题目中提到的升序旋转数组其实看看例子就可以发现，每个最小的数字都是转折点。如果旋转个数为 0，那么第一个数字就是最小的。  所以直接考虑初始化最小数字为第一个，之后遍历数组，如果遇到比第一个数字更小的数字那一定是转折点，也是整个数组的最小值。 ","date":"2022-03-05 22:37:23","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/:2:0","tags":["LeetCode","Java","旋转数组","最小数字"],"title":"LeetCode 之 剑指 Offer 11. 旋转数组的最小数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/"},{"categories":["LeetCode"],"content":"三、代码 class Solution { public int minArray(int[] numbers) { int n = numbers.length; int nMin = numbers[0]; for(int i=1;i\u003cn;i++){ if(numbers[i]\u003cnMin){ return numbers[i]; } } return nMin; } } ","date":"2022-03-05 22:37:23","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/:3:0","tags":["LeetCode","Java","旋转数组","最小数字"],"title":"LeetCode 之 剑指 Offer 11. 旋转数组的最小数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 10- II. 青蛙跳台阶问题（Java），一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。利用函数思维转换为斐波那契数列问题，再采用递归或者记忆化数组解决。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:37:21","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/:0:0","tags":["LeetCode","Java","青蛙跳台阶"],"title":"LeetCode 之 剑指 Offer 10  II. 青蛙跳台阶问题（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 10- II. 青蛙跳台阶问题 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：2 示例 2： 输入：n = 7 输出：21 示例 3： 输入：n = 0 输出：1 提示： 0 \u003c= n \u003c= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:37:21","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/:1:0","tags":["LeetCode","Java","青蛙跳台阶"],"title":"LeetCode 之 剑指 Offer 10  II. 青蛙跳台阶问题（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/"},{"categories":["LeetCode"],"content":"二、解题思路  这道题感觉其实还是挺巧妙的，如果没想通一下子也不好做。好吧，其实就是做题太少，自己太菜。 一开始我还想着按照正常思路这道题该怎么解，先假设全部为一跳完成，然后再有1个两跳，再2个两跳，最多n/2个两跳，将这些加起来就是最终的跳法。 然后代码不知从何下手。  对于这道题在最开始其实有个小提示，就是示例中的 f(0)=1 。 f(0)=1 f(1)=1 f(2)=2 ……  f(2) 是怎么来的呢？要么f(1)跳一跳，要么f(0)跳两跳。So，f(2)=f(2-1)+f(2-2)……f(n)=f(n-1)+f(n-2)，到这里是不是就很眼熟了呢？这不就是斐波那契数列嘛！ LeetCode 之 剑指 Offer 10- I. 斐波那契数列（Java）  对于算法题，如果不能理解题目，肯定就是先按照正常生活中的思路去找解决方式理解题目，然后再进一步转化为代码。但是，其实即便不能在生活中解决直接上代码思维也是可以的，本来程序就是为了解决生活中的不便之处。特别像这道题，利用函数推导思维可以很快想出来，但是从生活中入手就有些局限了。  另，题目给的示例还是要仔细看一下，像这道题那个 f(0)=1 就是在示例中给出的，一般人默认肯定是0。 ","date":"2022-03-05 22:37:21","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/:2:0","tags":["LeetCode","Java","青蛙跳台阶"],"title":"LeetCode 之 剑指 Offer 10  II. 青蛙跳台阶问题（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/"},{"categories":["LeetCode"],"content":"三、代码 class Solution { public int numWays(int n) { int constant = 1000000007; if(n==0){ return 1; } if(n==1){ return 1; } int[] nums = new int[n+1]; nums[0] = 1; nums[1] = 1; for(int i=2; i\u003cn+1; i++){ nums[i] = (nums[i-1] + nums[i-2])%constant; } return nums[n]; } } ","date":"2022-03-05 22:37:21","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/:3:0","tags":["LeetCode","Java","青蛙跳台阶"],"title":"LeetCode 之 剑指 Offer 10  II. 青蛙跳台阶问题（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 10- I. 斐波那契数列（Java），写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。最直接的方法当然是用递归，但是递归耗时过多，不适用，本文结合相关题解提供一个记忆化数组的方法进行解决。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:37:20","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/:0:0","tags":["LeetCode","Java","斐波那契数列"],"title":"LeetCode 之 剑指 Offer 10  I. 斐波那契数列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 10- I. 斐波那契数列 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 提示： 0 \u003c= n \u003c= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:37:20","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/:1:0","tags":["LeetCode","Java","斐波那契数列"],"title":"LeetCode 之 剑指 Offer 10  I. 斐波那契数列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/"},{"categories":["LeetCode"],"content":"二、解题思路  首先想到的自然是递归遍历法，但是这样的话O(n)就是2^n，最多到41可以行，之后就超时了。 后面看看解答，其实递归遍历就是从后向前不断计算，然后很多个数据都会重复计算，这样的话也就导致数据越大就越容易超时了。 所以，其实一想，既然反正都是要一个个计算，何不一开始就逐个计算下去呢？直到计算到n的前一个，然后就可以直接运用公式计算F(N)了。这样的O(N)也才N。 ","date":"2022-03-05 22:37:20","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/:2:0","tags":["LeetCode","Java","斐波那契数列"],"title":"LeetCode 之 剑指 Offer 10  I. 斐波那契数列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/"},{"categories":["LeetCode"],"content":"三、代码 class Solution { public int fib(int N) { // 记忆化 if(N\u003c=1){ return N; }else{ int[] nums = new int[N]; nums[0] = 0; nums[1] = 1; for(int i=2; i\u003cN; i++){ nums[i] = nums[i-1] + nums[i-2]; } return nums[N-1]+nums[N-2]; } // 递归遍历，O(N) 2^n // if(N\u003c=1){ // return N; // }else{ // return fib(N-1) + fib(N-2); // } } } ","date":"2022-03-05 22:37:20","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/:3:0","tags":["LeetCode","Java","斐波那契数列"],"title":"LeetCode 之 剑指 Offer 10  I. 斐波那契数列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 09. 用两个栈实现队列（Java），用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1。本文讲解实现思路和提供代码参考。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:37:19","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/:0:0","tags":["LeetCode","Java","两个栈实现队列"],"title":"LeetCode 之 剑指 Offer 09. 用两个栈实现队列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 09. 用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 \u003c= values \u003c= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:37:19","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/:1:0","tags":["LeetCode","Java","两个栈实现队列"],"title":"LeetCode 之 剑指 Offer 09. 用两个栈实现队列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/"},{"categories":["LeetCode"],"content":"二、解题思路 首先，理清楚概念： 栈：先进后出 队列：先进先出 其次，从外部看，我们只需要保证3点即可： 数据存储仍然是按照既定顺序的 每次插入都是在尾部 每次删除都是在头部 最后，根据题目提示和要求，实现思路： 初始化两个栈，一个作为输入栈，每次插入都将数据放到顶部，另一个作为输出栈，直接将输入栈数据依次弹出然后添加到输出栈那么顺序就反过来了，每次删除直接弹出输出栈顶部 构造函数初始化 插入函数直接将数据添加到输入栈顶部 删除函数弹出输出栈顶部，但是需注意先确保将输入栈数据传到了输出栈 ","date":"2022-03-05 22:37:19","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/:2:0","tags":["LeetCode","Java","两个栈实现队列"],"title":"LeetCode 之 剑指 Offer 09. 用两个栈实现队列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/"},{"categories":["LeetCode"],"content":"三、代码 class CQueue { Stack\u003cInteger\u003e addStack; Stack\u003cInteger\u003e delStack; public CQueue() { addStack = new Stack\u003cInteger\u003e(); delStack = new Stack\u003cInteger\u003e(); } public void appendTail(int value) { addStack.add(value); } public int deleteHead() { // 输出栈若为空，则从输入栈先传数据过来 if(delStack.isEmpty()){ while(!addStack.isEmpty()){ delStack.add(addStack.pop()); } } if(delStack.isEmpty()){ return -1; }else{ return delStack.pop(); } } } /** * Your CQueue object will be instantiated and called as such: * CQueue obj = new CQueue(); * obj.appendTail(value); * int param_2 = obj.deleteHead(); */ ","date":"2022-03-05 22:37:19","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/:3:0","tags":["LeetCode","Java","两个栈实现队列"],"title":"LeetCode 之 剑指 Offer 09. 用两个栈实现队列（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 07. 重建二叉树（Java），输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。本文简单描述解题思路，如何重新划分前序遍历和中序遍历的二叉树根节点、左右子树，并提供实现代码。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:37:18","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/:0:0","tags":["LeetCode","Java","重建二叉树"],"title":"LeetCode 之 剑指 Offer 07. 重建二叉树（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 07. 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 限制： 0 \u003c= 节点个数 \u003c= 5000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:37:18","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/:1:0","tags":["LeetCode","Java","重建二叉树"],"title":"LeetCode 之 剑指 Offer 07. 重建二叉树（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/"},{"categories":["LeetCode"],"content":"二、解题思路 前序遍历：根节点、左子树、右子树 中序遍历：左子树、根节点、右子树 理解基本概念后，我们很容易看出，可以对其进行划分，得到根节点和左右子树，然后对左右子树再递归划分，就可以得到最终重建的二叉树。 对原始数组划分根节点、左右子树 判断是否生成左右子树，如果生成则调用递归函数传入左右子树的数据信息，包含前序数组中的开始下标、中序数组中的开始下标、树长度 在递归函数中则是不断对传入的左右子树进行三部分划分 ","date":"2022-03-05 22:37:18","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/:2:0","tags":["LeetCode","Java","重建二叉树"],"title":"LeetCode 之 剑指 Offer 07. 重建二叉树（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/"},{"categories":["LeetCode"],"content":"三、代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { // 判断输入是否为空 if(preorder.length == 0){ return null; } TreeNode start = new TreeNode(preorder[0]); // 第一次划分左右子树 for(int i=0; i\u003cinorder.length; i++){ if(inorder[i] == preorder[0]){ //判断是否创建左子树，即前序和中序的第一个数据是否相同 if(i != 0){ start.left = bulidBranch(preorder, inorder, start.left, 1, 0, i); } // 判断是否创建右子树，即该根节点右侧是否还有数据 if(i+1 \u003c inorder.length){ start.right = bulidBranch(preorder, inorder, start.right, 1+i, i+1, inorder.length-i-1); } } } return start; } // preStart:前序开始的下标, inStart:中序开始的下标, n:本次子树的长度 TreeNode bulidBranch(int[] preorder, int[] inorder, TreeNode root, int preStart, int inStart, int n){ root = new TreeNode(preorder[preStart]); for(int i=inStart; i\u003cinStart+n; i++){ if(inorder[i] == preorder[preStart]){ if(i != inStart){ root.left = bulidBranch(preorder, inorder, root.left, preStart+1, inStart, i-inStart); } if(i+1 \u003c inStart+n){ root.right = bulidBranch(preorder, inorder, root.right, preStart+i-inStart+1, i+1, n-(i-inStart)-1); } } } return root; } } ","date":"2022-03-05 22:37:18","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/:3:0","tags":["LeetCode","Java","重建二叉树"],"title":"LeetCode 之 剑指 Offer 07. 重建二叉树（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java），输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。本文主要分析解题思路并提供三种解法，分别是——1. “栈” + Stack，2. “栈” + ArrayList，3. 递归 + ArrayList。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:0:0","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 06. 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2] 输出：[2,3,1] 限制： 0 \u003c= 链表长度 \u003c= 10000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:1:0","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"二、解题思路 本题两个难点： 单向链表无法随机访问数据，即无法直接从后获取数据 返回数组长度不定 单向链表逆序输出，那么也就是前面的最后输出，正好是栈的思想——先进后出。 然后单向链表的遍历时不可避免的，那么我们可不可以在遍历过程直接先从后往前输出呢？那就是递归。 所以本题两种解决思路: ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:2:0","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"栈 我们使用栈本质上是因为需要先获取再逆序保存，那么其实也有两种解法： 直接使用Stack 遍历链表读取数据到栈中 根据栈的 size 创建返回的数组 遍历数组获取栈中值，栈此时输出的就是逆向的链表数据 时间复杂度：O(N)，遍历单向链表读取，遍历数组保存 空间复杂度：O(N)，栈保存数据 使用不定长数组ArrayList后逆序保存到输出结果 遍历链表直接保存数据到ArrayList 根据已经得到的ArrayList长度创建返回数组 遍历返回数组，从后读取ArrayList数据到返回数组中 时间复杂度：O(N)，遍历单向链表读取，遍历数组保存 空间复杂度：O(N)，ArrayList保存数据 ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:2:1","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"递归 递归其实也需要利用一个数组来保存中间值，也只能是不定长数组ArrayList 利用递归函数得到逆序的数组，判断head是否为null，是则结束，不是则调用该函数继续递归 根据ArrayList长度创建返回数组 直接顺序保存ArrayList中的数据到返回数组中 时间复杂度：O(N)，遍历单向链表读取，遍历数组保存 空间复杂度：O(N)，ArrayList保存数据 ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:2:2","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"三、代码 ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:3:0","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"1. “栈” + Stack /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int[] reversePrint(ListNode head) { //1.1 直接调用Stack Stack\u003cListNode\u003e stack = new Stack\u003cListNode\u003e(); //链表数据入栈 ListNode temp = head; while(temp != null){ stack.push(temp); temp = temp.next; } //栈数据存到数组 int size = stack.size(); int[] arr = new int[size]; for(int i=0; i\u003csize; i++){ arr[i] = stack.pop().val; } return arr; } } ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:3:1","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"2. “栈” + ArrayList /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int[] reversePrint(ListNode head) { //1.2 借用ArrayList实现栈 ArrayList\u003cInteger\u003e temp = new ArrayList\u003cInteger\u003e(); while(head != null){ temp.add(head.val); head = head.next; } int arrLen = temp.size(); int[] arr = new int[arrLen]; for(int i=0; i\u003carrLen; i++){ arr[i] = temp.get(arrLen-1-i); } return arr; } } ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:3:2","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"3. 递归 + ArrayList /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution{ ArrayList\u003cInteger\u003e temp = new ArrayList\u003cInteger\u003e(); public int[] reversePrint(ListNode head){ m(head); int[] arr = new int[temp.size()]; for(int i=0; i\u003carr.length; i++){ arr[i] = temp.get(i); } return arr; } void m(ListNode head){ if(head == null){ return; } m(head.next); temp.add(head.val); } } ","date":"2022-03-05 22:35:56","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/:3:3","tags":["LeetCode","Java","从尾到头打印链表"],"title":"LeetCode 之 剑指 Offer 06. 从尾到头打印链表（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8java/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 05. 替换空格（Java），请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。解题思路：创建一个返回字符串，然后遍历原字符串利用字符串函数拼接或者替换后拼接即可。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:34:13","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/:0:0","tags":["LeetCode","Java","替换空格"],"title":"LeetCode 之 剑指 Offer 05. 替换空格（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 05. 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 示例 1： 输入：s = \"We are happy.\" 输出：\"We%20are%20happy.\" 限制： 0 \u003c= s 的长度 \u003c= 10000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:34:13","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/:1:0","tags":["LeetCode","Java","替换空格"],"title":"LeetCode 之 剑指 Offer 05. 替换空格（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/"},{"categories":["LeetCode"],"content":"二、解题思路 创建一个返回字符串，然后遍历原字符串利用字符串函数拼接或者替换后拼接即可。 ","date":"2022-03-05 22:34:13","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/:2:0","tags":["LeetCode","Java","替换空格"],"title":"LeetCode 之 剑指 Offer 05. 替换空格（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/"},{"categories":["LeetCode"],"content":"三、代码 class Solution { public String replaceSpace(String s) { // 遍历替换 String s2 = \"\"; for(int i=0; i\u003cs.length(); i++){ if(s.charAt(i)==' '){ s2 = s2.concat(\"%20\"); }else{ s2 = s2.concat(String.valueOf(s.charAt(i))); } } return s2; } } ","date":"2022-03-05 22:34:13","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/:3:0","tags":["LeetCode","Java","替换空格"],"title":"LeetCode 之 剑指 Offer 05. 替换空格（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BCjava/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java），在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。本文简要分析解题思路，提供暴力遍历和规律性删减法。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:30:41","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/:0:0","tags":["LeetCode","Java","二维数组查找"],"title":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 04. 二维数组中的查找 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 \u003c= n \u003c= 1000 0 \u003c= m \u003c= 1000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:30:41","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/:1:0","tags":["LeetCode","Java","二维数组查找"],"title":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/"},{"categories":["LeetCode"],"content":"二、解题思路 这道题的数据范围限制1000，倒也不影响遍历，但是既然数组是存在规律性的分布，那么肯定也就有更优的解法了。 解法1：遍历 暴力遍历每行每列，判断是否存在 target，反正也不会超时 O(n*m) 解法2：判断舍弃不必要的列 按照数组的规律，可以发现在当前行当我们从右往左遍历时，如果该数字大于 target，那么也就意味该列的数据都是大于 target 的，所以该列也就没有继续比较的必要了。 然后我们只需要遍历第一个小于 target 的列和所有行。 O(n*i) 解法3：对比删减行列法 在解法2的基础上，我们可以发现，如果当前行该列的数据小于 target 时，其实也就意味着该行可以不必比较了（我们从右往左遍历，所有目前的数据的左边的数据都是小于 target） 这样的话，我们可以选择从右上角出发进行查找，如果该数据小于target，则下一行，等于return，大于target，左一列 第一步：判断数组是否为空 第二步：右上角数据出发比对遍历循环 第三步：该数据 == target，return true 该数据 \u003e target，列– 该数据 \u003c target，行++ O(n+m) ","date":"2022-03-05 22:30:41","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/:2:0","tags":["LeetCode","Java","二维数组查找"],"title":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/"},{"categories":["LeetCode"],"content":"三、代码 ","date":"2022-03-05 22:30:41","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/:3:0","tags":["LeetCode","Java","二维数组查找"],"title":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/"},{"categories":["LeetCode"],"content":"1. 遍历 class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if(matrix==null || matrix.length==0 || matrix[0].length==0){ return false; } // int b=0; int n = matrix.length; int m = matrix[0].length; 1.遍历 O(n*m) for(int i=0; i\u003cn; i++){ for(int j=0; j\u003cm; j++){ if(matrix[i][j] == target){ return true; } } } return false; } } ","date":"2022-03-05 22:30:41","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/:3:1","tags":["LeetCode","Java","二维数组查找"],"title":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/"},{"categories":["LeetCode"],"content":"2. 判断舍弃不必要的列 class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if(matrix==null || matrix.length==0 || matrix[0].length==0){ return false; } // int b=0; int n = matrix.length; int m = matrix[0].length; //2.查找，舍弃不必要的列 O(m+n*b) for(int i=m-1; i\u003e=0; i--){ if(matrix[0][i]\u003ctarget){ b = i; break; } if(matrix[0][i] == target){ return true; } } for(int i=b; i\u003e=0; i--){ for(int j=0; j\u003cn; j++){ if(matrix[j][i] == target){ return true; } } } return false; } } ","date":"2022-03-05 22:30:41","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/:3:2","tags":["LeetCode","Java","二维数组查找"],"title":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/"},{"categories":["LeetCode"],"content":"3. 对比删减行列法 class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if(matrix==null || matrix.length==0 || matrix[0].length==0){ return false; } // int b=0; int n = matrix.length; int m = matrix[0].length; //3.对比删减遍历查找 O(n+m) int row = 0; int col = m-1; while(row\u003cn \u0026\u0026 col\u003e=0){ if(matrix[row][col] == target){ return true; } if(matrix[row][col] \u003e target){ col--; }else{ row++; } } return false; } } ","date":"2022-03-05 22:30:41","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/:3:3","tags":["LeetCode","Java","二维数组查找"],"title":"LeetCode 之 剑指 Offer 04. 二维数组中的查找（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BEjava/"},{"categories":["LeetCode"],"content":"LeetCode 之 剑指 Offer 03. 数组中重复的数字（Java），在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。创建重复数组进行遍历判断。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 22:25:42","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/:0:0","tags":["LeetCode","Java","重复数字"],"title":"LeetCode 之 剑指 Offer 03. 数组中重复的数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/"},{"categories":["LeetCode"],"content":"一、题目 剑指 Offer 03. 数组中重复的数字 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 \u003c= n \u003c= 100000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 ","date":"2022-03-05 22:25:42","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/:1:0","tags":["LeetCode","Java","重复数字"],"title":"LeetCode 之 剑指 Offer 03. 数组中重复的数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/"},{"categories":["LeetCode"],"content":"二、解题思路 此题比较巧妙，长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内，找出任意重复的一个数字，那么可以直接创建一个等长的数组，默认值均为0，然后遍历原数组中的值，先判断改以该值为下标的复制数组中的数据是否为0，如果是，则将其改为1，表示已经有数值了，等后面再次遇到该值为下标时，则复制数组的数据不再为1，表示重复了。 简单讲，将原始数组中的每个数值放到复制数组中的以该值为下标的位置处，并将该位置值改为1，表示有该数据，然后在后续遍历遇到该数据发现是1则重复了。 ","date":"2022-03-05 22:25:42","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/:2:0","tags":["LeetCode","Java","重复数字"],"title":"LeetCode 之 剑指 Offer 03. 数组中重复的数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/"},{"categories":["LeetCode"],"content":"三、代码 class Solution { public int findRepeatNumber(int[] nums) { int n = nums.length; int[] a = new int[n]; int result = 0; for(int i=0; i\u003cn; i++){ if(a[nums[i]] == 0){ a[nums[i]] = 1; }else{ result = nums[i]; break; } } return result; } } ","date":"2022-03-05 22:25:42","objectID":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/:3:0","tags":["LeetCode","Java","重复数字"],"title":"LeetCode 之 剑指 Offer 03. 数组中重复的数字（Java）","uri":"https://zz2summer.github.io/leetcode-%E4%B9%8B-%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97java/"},{"categories":["服务器"],"content":"本文主要是讲解如何在 Linux 环境下离线安装以及测试杀毒软件 clamav 0.104.2（以CentOS7为例），包括下载安装、配置参数和运行。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2022-03-05 21:03:00","objectID":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/:0:0","tags":["Linux","杀毒软件","ClamAV0.104.2","离线安装"],"title":"Linux下杀毒软件clamav0.104.2离线安装及测试（CentOS7）","uri":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/"},{"categories":["服务器"],"content":"1.下载安装 clamav 官网下载 clamav-0.104.2.linux.x86_64.rpm 将该文件上传至服务器，安装命令如下： rpm -ivh --prefix=/usr/local/clamav clamav-0.104.2.linux.x86_64.rpm ","date":"2022-03-05 21:03:00","objectID":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/:1:0","tags":["Linux","杀毒软件","ClamAV0.104.2","离线安装"],"title":"Linux下杀毒软件clamav0.104.2离线安装及测试（CentOS7）","uri":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/"},{"categories":["服务器"],"content":"2. 配置 添加用户组和组成员 groupadd clamav useradd -g clamav clamav 创建日志目录和病毒库目录 mkdir -p /usr/local/clamav/logs mkdir -p /usr/local/clamav/update 创建日志文件 touch /usr/local/clamav/logs/clamd.log touch /usr/local/clamav/logs/freshclam.log 文件授权 chown clamav:clamav /usr/local/clamav/logs/clamd.log chown clamav:clamav /usr/local/clamav/logs/freshclam.log chown clamav:clamav /usr/local/clamav/update 修改配置文件 cp /usr/local/clamav/etc/clamd.conf.sample /usr/local/clamav/etc/clamd.conf cp /usr/local/clamav/etc/freshclam.conf.sample /usr/local/clamav/etc/freshclam.conf 文件1：clamd.conf vim /usr/local/clamav/etc/clamd.conf #Example　//注释掉这一行 #添加以下内容 LogFile /usr/local/clamav/logs/clamd.log PidFile /usr/local/clamav/update/clamd.pid DatabaseDirectory /usr/local/clamav/update 文件2：freshclam.conf vim /usr/local/clamav/etc/freshclam.conf #Example　//注释掉这一行 #添加以下内容 DatabaseDirectory /usr/local/clamav/update UpdateLogFile /usr/local/clamav/logs/freshclam.log PidFile /usr/local/clamav/update/freshclam.pid 将这两个文件复制一下： cp /usr/local/clamav/etc/*.conf /usr/local/etc/ ","date":"2022-03-05 21:03:00","objectID":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/:2:0","tags":["Linux","杀毒软件","ClamAV0.104.2","离线安装"],"title":"Linux下杀毒软件clamav0.104.2离线安装及测试（CentOS7）","uri":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/"},{"categories":["服务器"],"content":"3. 运行 下载病毒库文件并上传到目录 /usr/local/clamav/update main.cvd daily.cvd bytecode.cvd 注：也可以在有网络的机器上运行如下命令更新病毒库： /usr/local/clamav/bin/freshclam 配置库文件路径 vim /etc/ld.so.conf 追加一行： /usr/local/clamav/lib64 更新生效： ldconfig 如果最后运行时仍然报错： clamscan: error while loading shared libraries: libclamav.so.9: cannot open shared object file: No such file or directory 则说明配置没有生效。 创建命令软件链接 ln -s /usr/local/clamav/bin/clamscan /usr/local/bin/clamscan 运行使用 clamscan -r 卸载程序 rpm remove clamav ","date":"2022-03-05 21:03:00","objectID":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/:3:0","tags":["Linux","杀毒软件","ClamAV0.104.2","离线安装"],"title":"Linux下杀毒软件clamav0.104.2离线安装及测试（CentOS7）","uri":"https://zz2summer.github.io/linux%E4%B8%8B%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6clamav%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95centos7/"},{"categories":["Tools"],"content":"本文内容主要讲解如何利用 Hexo + Github Page 搭建个人博客，内容包含基本工具（Node.js、Git、Github、Hexo）的安装使用、如何利用Hexo进行发布、修改、删除文章、图片添加水印等细节。 本文修改自【韦阳】的博客《超详细Hexo+Github博客搭建小白教程》 原文链接：https://godweiyang.com/2018/04/13/hexo-blog/ 遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"快速搭建 已经搭建和配置好的模板：https://github.com/zz2summer/blog-hexo-theme-matery.git，下载后，先解压 node_modules.zip，然后删除 .git 如果出现bug，可能是npm版本等问题，可以把 node_moudules 文件删除，重新安装对应模块组件 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"安装Node.js 官网下载：Node.js 安装直接点击 Next 即可 最后测试是否安装成功： 用 win + R 打开命令行提示符，输入 cmd，之后输入命令：node -v、npm -v，如果显示版本号即安装成功！ ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"添加国内镜像源 可以切换使用阿里的国内镜像对 npm 进行加速 # 设置自定义镜像命令 npm config set registry https://registry.npm.taobao.org # 查看npm源地址 npm config list # 删除自己设置的镜像命令 npm config rm registry ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"安装 Git 下载分布式版本管理工具 Git —— 主要用于之后把本地网页部署到 Github 上去 安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。 安装完成后在命令提示符中输入git --version验证是否安装成功。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"注册 Github 打开https://github.com/，新建一个项目，如下所示： 然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的github名字完全一样，比如你github名字叫abc，那么仓库名字一定要是abc.github.io。 然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，会变成下面这样： 点击那个链接，就会出现自己的网页啦，效果如下： ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"安装Hexo 在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在H:\\blog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。 定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。 安装完后输入hexo -v验证是否安装成功。 然后就要初始化我们的网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。 这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下： 按ctrl+c关闭本地服务器。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:6:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"连接Github与本地 首先右键打开git bash，然后输入下面命令： git config --global user.name \"zz2summer\" git config --global user.email \"xxxxx@163.com\" 用户名和邮箱根据你注册github的信息自行修改。 然后生成密钥SSH key： ssh-keygen -t rsa -C \"summer2zz@163.com\" 按照提示直接一路回车即可。 打开 github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。 git bash中输入 cat ~/.ssh/id_rsa.pub 将输出的内容复制到新建 SSH的框中，点击确定保存。 输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。 修改最后一行的配置： deploy: type: git repository: https://github.com/zz2summer/zz2summer.github.io branch: master repository修改为你自己的github项目地址。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:7:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"写文章、发布文章 首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。 然后输入hexo new post \"article title\"，新建一篇文章。 然后打开H:\\blog\\source\\_posts的目录，可以发现下面多了一个article-title.md文件，就是文章文件。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。 如果需要上传图片，需要修改配置文件_config.yml来生成。 post_asset_folder: true 这样每次新建文件就会直接生成文章和同名文件夹，图片放到文件夹中再用相对路径引用图片即可。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:8:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"图片添加水印 为了防止别人抄袭你文章，可以把所有的图片都加上水印，方法很简单。 首先在博客根目录下新建一个watermark.py，代码如下： # -*- coding: utf-8 -*- import sys import glob from PIL import Image from PIL import ImageDraw from PIL import ImageFont def watermark(post_name): if post_name == 'all': post_name = '*' dir_name = 'source/_posts/' + post_name + '/*' for files in glob.glob(dir_name): im = Image.open(files) if len(im.getbands()) \u003c 3: im = im.convert('RGB') print(files) font = ImageFont.truetype('STSONG.TTF', max(30, int(im.size[1] / 20))) draw = ImageDraw.Draw(im) text_size_x, text_size_y = draw.textsize(u'@yourname', font=font) draw.text((im.size[0] - text_size_x, im.size[1] - text_size_y), u'@yourname', fill=(0, 0, 0, 85), font=font) im.save(files) if __name__ == '__main__': if len(sys.argv) == 2: watermark(sys.argv[1]) else: print('[usage] \u003cinput\u003e') 字体也放根目录下，自己找字体。（win10自带字体文件目录：C:\\Windows\\Fonts）然后每次写完一篇文章可以运行python watermark.py postname添加水印，如果第一次运行要给所有文章添加水印，可以运行python watermark.py all。 如果报错显示：ModuleNotFoundError: No module named 'PIL'，意思没有安装对应的 Python 模块，运行命令：pip install Pillow ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:9:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"修改样式 建议参考官方说明文档：hexo-theme-matery/README_CN.md at develop · blinkfox/hexo-theme-matery 详细而且是最新的。 注意区分博客的配置文件和主题的配置文件，基本上把两个配置文件浏览一遍，基本配置就改好了。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:10:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"文章基本操作 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:11:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"发表文章 # 新建文章 hexo new post \"article title\" # 图片加水印 # 单篇文章 postname python watermark.py postname # 所有文章 python watermark.py all # 生成静态页面 hexo g # 本地预览 hexo s # 部署到网站 hexo d ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:11:1","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"修改文章 修改对应文章内容，然后执行命令 hexo d -g 即可。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:11:2","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"删除文章 删除目录 source\\_posts 下对应文章文件，然后执行命令 hexo d -g 即可。 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:11:3","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"其他 多个标签：[标签1,标签2,标签3] 插入上传图片 将图片放置在在 .md 同级目录下的同名文件夹下，引用时直接写图片名即可，如：![](pic_name.png)，部署后该HTML页面和图片位于同级目录 将图片放置在在 source/images 目录下，引用时使用![](/images/pic_name.png) ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:11:4","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"Hexo 常见操作 # Create a new post $ hexo new \"My New Post\" # Run server $ hexo server # Generate static files $ hexo generate # Deploy to remote sites $ hexo deploy # 清空缓存并生成新的静态页面 hexo clean \u0026\u0026 hexo g ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:12:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"遇到的问题 因为开了代理，所以连接上可能会出现一些问题 Summer@DESKTOP-NU751AT MINGW64 /h/blog/themes $ git clone https://github.com/blinkfox/hexo-theme-matery.git Cloning into 'hexo-theme-matery'... fatal: unable to access 'https://github.com/blinkfox/hexo-theme-matery.git/': OpenSSL SSL_read: Connection was reset, errno 10054 Summer@DESKTOP-NU751AT MINGW64 /h/blog/themes $ git config --global http.proxy 127.0.0.1:8580 ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:13:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"参考文章 【1】超详细Hexo+Github博客搭建小白教程 | 韦阳的博客 【2】Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 【3】hexo-theme-matery/README_CN.md at develop · blinkfox/hexo-theme-matery ","date":"2021-03-28 14:30:49","objectID":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:14:0","tags":["Hexo","Github","个人博客"],"title":"Github + Hexo 搭建个人博客","uri":"https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"利用 Hugo + Github Page 搭建个人博客，主要流程和配置记录，包含：第一次搭建过程、日常文章操作、谷歌分析、访问计数、部署脚本、网站运行时间等细节优化和部分个人总结。","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"利用 Hugo + Github Page 搭建个人博客，主要流程和配置记录，包含：第一次搭建过程、日常文章操作、谷歌分析、访问计数、部署脚本、网站运行时间等细节优化和部分个人总结。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"零、效果 本次配置最终效果图： 快速搭建方式，直接下载修改后的模板改也是可以的：https://github.com/zz2summer/blog-hugo-theme-LoveIt 完成步骤一、二、三，然后下载上述文件到 blog 目录下就可以跳过第四步了。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"一、创建 Github 库 打开 Github ，新建一个库。 输入项目名，要与 Github 用户名一致。比如我的是 zz2summer，那么输入的 Repository name 就是 zz2summer.github.io，README 也一并勾选上。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"二、安装 Hugo 和 Git 查阅 Hugo 安装指南：Install Hugo | Hugo，找到对应系统的安装操作。 基本上都是使用各个包工具安装，本人 Win10，比较嫌麻烦就直接下载使用。 打开 Github 中的 Hugo 库，打开右侧的 Realeases，下载最新的版本，本次下载为：hugo_extended_0.82.0_Windows-64bit.zip 下载 extened 版本是因为有些主题的需要利用进行 SCSS/SASS 构建，如果下普通版就可能会报错显示： you need the extended version to build SCSS/SASS 解压后，将其中的 hugo.exe 放到指定的安装目录，比如 D:\\softwares\\Hugo\\bin，然后将该目录添加到系统环境变量（win+R → sysdm.cpl → 高级 → 环境变量 → 系统变量 Path）的 Path 下。 打开命令行，输入 hugo version，显示版本号即为安装成功 本地下载 Git ，Win10直接下载 exe ，点击下一步就好了。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"三、新建 Hugo 网站 新建一个目录，用于存放 Hugo 网站的文件，比如：H:\\HugoWebsite 打开命令行，切换到该目录，执行命令新建一个 Hugo 网站 # blog 是网站文件夹名 hugo new site blog ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"四、选择 Hugo 主题 打开 hugo theme 的网站，选择合适的主题，以Tranquilpeak 举例。 Hugo Themes: https://themes.gohugo.io 将选中的主题下载到本地 # 进入网站目录 blog cd blog # 进入 themes 目录，一般默认有，如果没有自行创建：mkdir -p themes cd themes # 下载主题到 tranquilpeak 文件夹下 git clone https://github.com/kakawait/hugo-tranquilpeak-theme.git tranquilpeak 此处建议选择的这个主题相较适合第一次尝试，配置文件比较详细明了。待熟悉后，可以自行选择主题。 Hugo主题库：https://themes.gohugo.io，个人推荐主题：https://github.com/dillonzq/LoveIt.git 在 Hugo 网站的根目录下（上文提及的 HugoWebsite）配置 config.toml 详细配置参考：hugo-tranquilpeak-theme/user.md at master · kakawait/hugo-tranquilpeak-theme 当前工作目录：H:\\HugoWebsite\\blog，备份 config.toml 原文件，然后将 themes/tranquilpeak/exampleSite/config.toml 复制过来覆盖原文件，打开 config.toml 阅读并修改配置 简单讲就是利用已经配置好的主题配置文件进行修改。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:5:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"五、新建文章 进入网站文件夹根目录：H:\\HugoWebsite\\blog，鼠标右键选择 Git Bash Here 新建文章：first-post.md，**注意区分主题的要求，有些主题新建文章的目录是 posts ** hugo new post/first-post.md 编辑文章内容，保存。 启动 Hogo server hugo server -D 打开网址 http://localhost:1313/ 可以进行预览 如果发现预览效果不满意，可以 编辑 config.toml 文件 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:6:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"六、部署到 Github 构建 Hugo 网站 在 Hugo 网站文件夹的根目录（H:\\HugoWebsite\\blog）下执行 hugo 命令构建 Hugo 会将构建的网站内容默认保存至网站根目录下的 public/ 文件夹下。 将网站文件夹与 GitHub 建立联系**（仅第一次运行需要）** 进入 H:\\HugoWebsite\\blog\\public 目录，初始化 Git 库 生成的 HTML 文件保存在 “public” 目录中，“public” 文件夹会被转换为 Git 库。 git init 将 Git 本地库关联至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，为 Git 本地库添加远程库，“git@github.com:your-github-id/your-github-id.github.io.git” git remote add origin git@github.com:zz2summer/zz2summer.github.io.git 提交修改 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： # 查看当前修改状态 git status # 添加修改过得文件， . 表示所有，也可以指定文件 git add . # \"\"里面的内容就是提交内容的说明信息 git commit -m \"first commit\" 提交修改至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： git push -u origin master 然后如果按照博客顺序操作，第一次应该失败的。 因为本地的 git 库和远程的库并不是一致的，需要进行一次 pull 操作才能继续 push。 第一种解决办法就是加参数 -f ，强制推送，但是这样很危险，会导致其他的更新提交失败，也就是说原来该库下所有文件都会被删除掉，只剩下本次提交的文件了。日常不建议这么操作，但是其实本次第一次是可以的，因为当前库下没有还没有有效文件。 git push -u -f origin master 第二种方案为：先把除 .git 文件夹外的所有文件复制到其他目录备份，然后 git pull 当前库下的文件下来，然后把这些文件和自己需要的文件结合处理好（本次就是删除这些文件，再把原文件复制回来），重新提交即可。日常推荐这种方法，养成好习惯。 # 1.移动除 .git 外的文件到另一个目录下 # 2.pull 该库当前文件，最后的参数是因为合并两个不相关的项目（即，不知道彼此存在并且提交历史不匹配的项目）时，会发生Git错误：fatal: refusing to merge unrelated histories，此时出现记录文件，先按住 ctrl+:，再输入 wq 即可。 git pull origin master --allow-unrelated-histories # 3.合并这些文件和第一次移动出去的文件，本次就是删除这些文件，把那些文件移动回来就好了 # 4.提交本地 git add . git commit -m \"first commit\" # 5.提交远程 git push -u origin master 好了，第一次初始化配置也就成功完成了！输入：https://zz2summer.github.io/ 就可以访问部署的网站了。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:7:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"七、日常操作 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:8:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"1. 新建文章 # 1.新建一篇文章，在网站根目录：H:\\HugoWebsite\\blog hugo new post/第二篇测试博客.md # 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件进行修改 # 3.本地预览, http://localhost:1313/ hugo server -D # 4.构建 Hugo 网站 hugo # 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m 'commit info' # 6.将修改推至远程库 git push -u origin master ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:8:1","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"2. 修改文章 # 1.当前工作目录：H:\\HugoWebsite\\blog # 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件 进行修改 # 3.本地预览, http://localhost:1313/ hugo server -D # 4.构建 Hugo 网站 hugo # 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m 'commit info' # 6.将修改推至远程库 git push -u origin master ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:8:2","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"3. 删除文章 # 1.当前工作目录：H:\\HugoWebsite\\blog # 2.删除两处文件 在目录 H:\\HugoWebsite\\blog\\content\\post 、H:\\HugoWebsite\\blog\\public 下找到对应文件进行删除 其中 public 下文件不删除也不影响显示，只是该文件就会一直存在，另外该目录下即便文件（除.git)删错或者全部删除也是不影响的，应为 hugo 命令会全部重建 # 3.本地预览, http://localhost:1313/ hugo server -D # 4.构建 Hugo 网站 hugo # 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m 'commit info' # 6.将修改推至远程库 git push -u origin master ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:8:3","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"4.添加图片 Hugo 的配置文件和文章中引用图片都是从static作为根目录的。（H:\\HugoWebsite\\blog\\static） 也就是说首先要将图片放置到 static 文件夹下，以 static 为相对路径，然后进行引用，方式为：![](pic_name.png)，当然这样该 .md 文件中是不会显示，本地预览和部署后是可以看到的 正常做法： 写文章时，在该文章目录下新建文件夹存放照片，引用时采用相对路径。 完成之后，在引用路径前加个 /，比如原来引用方式 ![](imgs/pic_name.png) ，需要修改为 ![](/imgs/pic_name.png) 。 之后将该图片文件夹移动到 static 目录下即可。 注意：如果该文件夹名包含空格可能会不能被显示，支持中文，但是不支持含空格。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:8:4","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"5. 图片加水印 找一份字体放到根目录下（H:\\HugoWebsite\\blog）。 （win10自带字体文件目录：C:\\Windows\\Fonts） 创建 watermark.py 然后每次写完一篇文章可以运行python watermark.py postname添加水印。 如果第一次运行要给所有文章添加水印，可以运行python watermark.py all。 # -*- coding: utf-8 -*- import sys import glob from PIL import Image from PIL import ImageDraw from PIL import ImageFont def watermark(post_name): if post_name == 'all': post_name = '*' dir_name = 'static/' + post_name + '/*' for files in glob.glob(dir_name): im = Image.open(files) if len(im.getbands()) \u003c 3: im = im.convert('RGB') print(files) font = ImageFont.truetype('arial.ttf', max(30, int(im.size[1] / 20))) draw = ImageDraw.Draw(im) # draw.text((im.size[0] / 2, im.size[1] / 2), u'@yourname', fill=(0, 0, 0), font=font) text_size_x, text_size_y = draw.textsize(u'@yourname', font=font) draw.text((im.size[0] - text_size_x, im.size[1] - text_size_y), u'@yourname', fill=(0, 0, 0, 85), font=font) im.save(files) if __name__ == '__main__': if len(sys.argv) == 2: watermark(sys.argv[1]) else: print('[usage] \u003cinput\u003e') ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:8:5","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"八、细节优化 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:9:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"1.谷歌分析的配置 获取 跟踪ID，https://analytics.google.com/ 添加如下代码到 \u003chead\u003e 标签中 \u003c!-- Global site tag (gtag.js) - Google Analytics --\u003e \u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=UA-xxxxxxxxx-x\"\u003e\u003c/script\u003e \u003cscript\u003e window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-xxxxxxxxx-x'); \u003c/script\u003e ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:9:1","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"2. 添加访问计数 参考如下代码，添加到想要加入的位置即可。 显示单页面访问量 要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 \u003cspan id=\"busuanzi_container_page_pv\"\u003e 本文总阅读量\u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e 显示站点总访问量 要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 \u003cspan id=\"busuanzi_container_site_pv\"\u003e 本站总访问量\u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 \u003cspan id=\"busuanzi_container_site_uv\"\u003e 本站访客数\u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e人次 \u003c/span\u003e 注：本地测试时数据会任意显示，部署后即正常 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:9:2","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"3.部署脚本 在目录 H:\\HugoWebsite\\blog 新建 deploy.sh ，在 Git bash 下运行：sh deploy.sh #!/bin/bash echo -e \"\\033[0;32mDeploying updates to GitHub...\\033[0m\" # Build the project. hugo # if using a theme, replace with hugo -t \u003cYOURTHEME\u003e # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site `date` \" echo -e \"\\033[0;32m$msg\\033[0m\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:9:3","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"4. 添加网站运行时间 在想要添加的位置（基本是 footer 文件）加入以下代码，其中开始运行的时间需要自行修改 \u003cscript\u003e function siteTime() { var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var startYear = 2021; var startMonth = 3; var startDate = 27; var startHour = 19; var startMinute = 15; var startSecond = 11; var todayYear = today.getFullYear(); var todayMonth = today.getMonth() + 1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond); var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); var diff = t2 - t1; var diffYears = Math.floor(diff / years); var diffDays = Math.floor((diff / days) - diffYears * 365); var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); if (startYear == todayYear) { //document.getElementById(\"year\").innerHTML = todayYear; document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } else { //document.getElementById(\"year\").innerHTML = startYear + \" - \" + todayYear; document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffYears + \" 年 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } } setInterval(siteTime, 1000); \u003c/script\u003e \u003cspan id=\"sitetime\"\u003e载入运行时间...\u003c/span\u003e ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:9:4","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"5. 图片放大功能 方法一： 部分主题自带了 lightgallery 效果，在配置文件设置为 true 即可。 方法二： 加载jqury和fancybox文件，在博客文件footer.html中添加下面的文件 \u003cscript src=\"https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js\"\u003e\u003c/script\u003e \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css\" /\u003e \u003cscript src=\"https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js\"\u003e\u003c/script\u003e 在博客文件中需要加载图片的地方插入下面html代码 \u003ca data-fancybox=\"gallery\" href=\"图片链接\"\u003e\u003cimg src=\"图片链接\"\u003e\u003c/a\u003e ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:9:5","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"九、总结 可以将主题下相关文件复制到 blog 网站根目录下，因为这样可以直接渲染网站效果，而又不影响主题本身的内容。 主要是 themes\\LoveIt\\exampleSite 目录下文件 发布文章如果有参数 draft ，记得将值设为 false，或者删除 draft，不然会被认定为草稿只能本地运行而不能运行到网站上。 基本上就是安装 Hugo ，建站，下载主题，配置主题参数，然后部署就是了。 ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:10:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["Tools"],"content":"参考文章 【1】How To Build A Personal Website with Hugo | Matteo Courthoud 【2】使用Hugo和GitHub搭建博客. 折腾了几天博客的框架终于搭建起来了。研究了一番之后，最终还是选择使用Hugo和G… | by Félix | Medium 【3】如何利用 GitHub Pages 和 Hugo 轻松搭建个人博客？ - 知乎 【4】把博客从 Hexo 迁移到 Hugo - jdhao’s blog ","date":"2021-03-28 13:14:16","objectID":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:11:0","tags":["Hugo","Github","个人博客"],"title":"Github Pages + Hugo 搭建个人博客","uri":"https://zz2summer.github.io/github-pages-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":[],"content":"新建 ","date":"2021-03-27 21:56:20","objectID":"https://zz2summer.github.io/about/:0:0","tags":[],"title":"About","uri":"https://zz2summer.github.io/about/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件工程基础中实验四，根据课程管理对象类图，采用Java在Eclipse下编码实现，并用JUnit框架对某Java类进行测试。针对某网站，采用selenium或SilkTest或SilkPerformer分别进行功能测试和性能测试。（选做）","date":"2019-08-04 19:06:55","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C4%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/","tags":["软件工程基础","实验4","系统实现"],"title":"软件工程基础 实验4《系统实现》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C4%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件工程基础中实验四，根据课程管理对象类图，采用Java在Eclipse下编码实现，并用JUnit框架对某Java类进行测试。针对某网站，采用selenium或SilkTest或SilkPerformer分别进行功能测试和性能测试。（选做） 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 实验4《系统实现》 一、实验目的 掌握：系统实现的有关技术及其相关工具。 二、实验内容 试对图3所示的课程管理对象类图，采用Java在Eclipse下编码实现，并用JUnit框架对某Java类进行测试。 图3 类图 针对某网站，采用selenium或SilkTest或SilkPerformer分别进行功能测试和性能测试。（选做） 三、实验方法 利用pycharm工具，python代码实现该课程管理系统； 利用python中的doctest和unittest等测试工具对系统中的代码进行测试。 四、实验步骤  4.1 需求说明： 课程管理系统  A、管理员：  创建老师：姓名、性别、年龄、资产  创建课程：课程名称、上课时间、课时费、关联老师 使用pickle保存在文件  B、学生：  学生：用户名、密码、性别、年龄、选课列表[]、上课记录  1、列举所有课程  2、选择课程  3、学生上课，  4、ret = 课程.work() 获取课程的返回; 资产+=课时费  4.2 代码思路  1.类的关联：  a、Teacher类：关联管理员，由哪个管理员创建  b、 Course类：关联老师对象、管理员对象（注意：关 联的是对象）  2.文件的写入：  a、管理员文件：写入的是管理员对象（封装管理员的用户名和密码）  b、学生文件：写入的是学生对象（封装了学生已选课程列表，已经上过的课程字典：key：课程对象 value：上课信息列表，是列表格式）  c、课程列表course_list、老师列表teacher_lis，都是列表格式。  4.3 文件概述  bin目录：存放administrator.py文件和students.py文件  config目录：存放settings.py文件，即配置文件  db目录：存放与数据相关的文件，包括课程列表course_list、老师列表teacher_list、学生文件夹、管理员文件夹  lib目录：存放models.py文件，即存放公共的模块  log目录：存放日志文件  4.4 代码实现  4.5 代码测试 五、实验结果  5.1 利用doctest测试students.py中的登录模块 def login(user, pwd): \"\"\" \u003e\u003e\u003e login(\"\",\"\") 用户账号或者密码输入为空 \u003e\u003e\u003e login(\"a\",\"1\") 账号或者密码错误 \u003e\u003e\u003e login(\"a\",\"123\") 登录成功 \"\"\" if (\"\".__eq__(user) | \"\".__eq__(pwd)): print('用户账号或者密码输入为空') else: if (\"a\".__eq__(user) \u0026 \"123\".__eq__(pwd) ): # 如果登陆成功 print(\"登录成功\") else: print('账号或者密码错误') if __name__ == '__main__': import doctest doctest.testmod(verbose=True)  测试结果：  结果分析：测试结果显示三个测试均成功通过，在用户登录时该模块能够对用户的输入进行正常判断，比如判空、账号密码核实。  5.2 利用unittest测试modules.py文件中的老师类Teacher teacher.py： import time class Teacher: \"\"\" 封装老师的相关信息 \"\"\" def __init__(self, name, age, admin): self.name = name self.age = age self.__assets = 0 self.create_time = time.strftime('%Y-%m-%d%H:%M:%S') self.create_admin = admin def gain(self, cost): \"\"\" 增加资产 :param cost: 增加的数量 :return: \"\"\" self.__assets += cost return self.__assets def decrease(self, cost): \"\"\" 减少资产 :param cost: 减少的数量 :return: \"\"\" self.__assets -= cost return self.__assets  unittestTeacher.py： import unittest from teacher import * class Test_teacher(unittest.TestCase): def setUp(self): print('test kick on') self.obj = Teacher(\"张三\",35,\"胡主任\") def test_gain(self): self.assertEqual(15,self.obj.gain(15)) print('test gain') def test_decrease(self): self.assertEqual(10,self.obj.decrease(5)) print('test decrease') def tearDown(self): print('test is over') if __name__=='__main__': unittest.main()  测试结果：  结果分析：根据结果显示，其中测试中两个通过，一个失败，在用户创建老师类时能够成功创建，增加资产时以初始态0为基础，所以加上15等于15，测试通过，但是减少资产时依旧以0为基础，所以此处减少后为-5，而不等于10，测试未通过。 六、实验结论  本次实验测试是进行抽样测试，根据不同的测试方式进行不同测试，测试样例、结果和结果分析见第五点显示，通过该实例测试方式可对本程序其余模块进行测试，从而验证所以模块的正确性。  根据本次测试结果，可知，对python进行不同方式的测试很有必要，因为测试是提高代码质量和可维护性的一种方式，也是成本最低的一种方式，尽早排除尽可能出现的bug，可以减少在后续阶段解决bug的成本（包括时间成本、人力成本等）。  项目源码展示如下：  6.1 配置文件settings.py import os BASE_DIR = os.path.dirname(os.path.dirname(__file__)) #配置文件的上级目录 BASE_ADMIN_DIR = os.path.join(BASE_DIR, \"db\", \"admin\") #管理员目录 BASE_STUDENTS_DIR = os.path.join(BASE_DIR, \"db\", \"students\") #学生目录 TEACHER_DB_DIR = os.path.join(BASE_DIR, \"db\", \"teacher_list\") #老师列表目录 COURSE_DB_DIR = os.path.join(BASE_DIR, \"db\", \"course_list\") #课程列表目录  6.2 公共模块modules.py #!/usr/bin/env python # -*- coding:utf-8 -*- import random import time import pickle from config import settings import os class Teacher: \"\"\" 封装老师的相关信息 \"\"\" def __init__(self, name, age, admin): self.name = name self.age = age self.__assets = 0 self.create_time = time.strftime('%Y-%m-%d%H:%M:%S') self.create_admin = admin def gain(self, cost): \"\"\" 增加资产 :param cost: 增加的数量 :return: \"\"\" self.__assets += cost def decrease(self, cost): \"\"\" 减少资产 :param cost: 减少的数量 :return: \"\"\" self.__assets -= cost class Course: \"\"\" 课程相关信息 \"\"\" def __init__(self, course_name, cost, teacher_obj, admin): self.course_name = course_name self.cost = cost self.teacher = teacher_obj self.create_time = time.strftime('%Y-%m-%d%H:%M:%S') self.create_admin = admin def have_lesson(self): \"\"\" 课程上课，自动给相关联的任课老师增加课时费 :return: 课程内容返回给上课者 \"\"\" self.teacher.gain(self.cost) c","date":"2019-08-04 19:06:55","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C4%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/:0:0","tags":["软件工程基础","实验4","系统实现"],"title":"软件工程基础 实验4《系统实现》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C4%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件工程实验三——试针对实验二的培训中心管理系统，试用结构化设计方法对其进行设计，并用Visio绘制其对应的软件结构图。（选做）根据某室内保温系统的描述，试据此对系统进行设计，采用Rational Rose绘制控制器的状态图，同时用顺序图描述锅炉启动过程。","date":"2019-08-04 18:54:30","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C3%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","tags":["软件工程基础","实验3","系统设计"],"title":"软件工程基础 实验3《系统设计》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C3%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件工程实验三——试针对实验二的培训中心管理系统，试用结构化设计方法对其进行设计，并用Visio绘制其对应的软件结构图。（选做）根据某室内保温系统的描述，试据此对系统进行设计，采用Rational Rose绘制控制器的状态图，同时用顺序图描述锅炉启动过程。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 实验3《系统设计》 一、实验目的 掌握：结构化数据流设计技术、面向对象设计技术； 掌握：Visio工具绘制软件结构图； 掌握：EA或Visio工具绘制UML模型图。 二、实验内容 试针对实验二的培训中心管理系统，试用结构化设计方法对其进行设计，并用Visio绘制其对应的软件结构图。（选做） 某室内保温系统的描述如下：  如果主开关置于“加热”状态，保温系统的控制器负责开关锅炉，监视锅炉系统的燃油流量和燃烧状态，进而调节进入房间的热流量。当室内温度降至（Tr-2）度以下，控制器启动锅炉。这里Tr 是用户设定的理想室温。锅炉启动过程如下：  （1）控制器向锅炉的马达发送信号；  （2）控制器监视马达速度。马达达到正常操作速度时，启动点火并打开油阀；  （3）控制器监视水温， 一旦水温达到预定值， 发信号打开水流循环阀。热水开始在室内循环。  （4）如果发生异常情况，燃油流量指示器和光感器向控制器发信号。此时控制器发信号关闭系统。  （5）一旦室内温度达到（Tr-2）度，控制器首先关闭油阀，延迟5秒钟后关闭锅炉马达。  系统须满足以下限制：  （1）锅炉停机后重启必须延迟5秒钟；  （2）在主开关关闭或油阀关闭5秒钟内应指示锅炉停机。  试据此对系统进行设计，采用Rational Rose绘制控制器的状态图，同时用顺序图描述锅炉启动过程。 三、实验方法  本次实验方法主要是利用Visio工具绘制软件结构图、状态图和顺序图；  实验原理是根据题目要求及图形要求进行绘制；  实验技术是Visio绘制；  实验方案是先根据题目要求将题目中的要求标志出来，然后记录所要绘制的图形的注意事项，再进行初稿绘制，初稿绘制完成后进行图形要点检查，最后进行图形展示优化。 四、实验步骤  Visio建立软件结构图的基本步骤： 先添加函数/子例程； 再添加有条件调用； 然后添加调用连线； 最后为调用线添加数据流或标志流。  Visio建立活动图的基本步骤： 打开Visio2010工具，选择【文件】→【新建】→【活动图】→【UML活动图】→【创建】，即可创建一个UML活动模板，之后在左侧选择适当图形进行UML活动图绘制；  Visio建立顺序图的基本步骤同建立活动图。 五、实验结果 实验二中的培训中心管理系统的软件结构图如下所示： 控制器的状态图如下所示： 锅炉启动过程的顺序图如下所示： 六、实验结论  本次实验主要是对项目进行系统设计，有软件结构图、状态图和顺序图等，通过一系列建模从而对项目实施路程更加了解，更加有利于项目计划开展。  实验结果的截图见第五点。 七、实验小结  给出本次实验的体会，如学会了什么，遇到哪些问题，如何解决这些问题，存在哪些有待改进的地方。  通过本次实验我主要学会了如何对项目进行系统设计，对系统整体进行抽象，提取出自己所关心的内容，从而有利于项目后续开发。软件架构图主要是展示项目的主要框架，有利于对项目的总体进行分析规划，活动图和顺序图主要是对系统的进一步解析，有利于系统的实际开发。  实验中遇到的问题主要是对图形的组件不够清楚，通过查阅书籍和网络资料解决，还有就是有一部分内容不能清晰表示，与同学课后交流解决。  实验存在的不足主要是图形中的关系不够了解，有一些地方可能存在错误。 参考文章：【1】软件工程基础实验 - 百度文库 ","date":"2019-08-04 18:54:30","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C3%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/:0:0","tags":["软件工程基础","实验3","系统设计"],"title":"软件工程基础 实验3《系统设计》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C3%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件工程试验三——某培训中心要研制一个计算机管理系统，根据描述中找出绘制数据流图的四种成分并用Visio绘制数据流图。有一简单选课系统，用文字描述如下，试用IDEF1X图和UML类图描述该系统的信息模型，并用Visio或EA绘制该IDEF1X图和UML类图。请用Visio或EA绘制如图2所示的用例图。","date":"2019-08-04 18:43:07","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C2%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/","tags":["软件工程基础","实验2","需求分析"],"title":"软件工程基础 实验2《需求分析》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C2%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件工程试验三——某培训中心要研制一个计算机管理系统，根据描述中找出绘制数据流图的四种成分并用Visio绘制数据流图。有一简单选课系统，用文字描述如下，试用IDEF1X图和UML类图描述该系统的信息模型，并用Visio或EA绘制该IDEF1X图和UML类图。请用Visio或EA绘制如图2所示的用例图。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 实验2《需求分析》 一、实验目的 了解：软件项目需求分析的基本原理与方法； 掌握：用例建模方法、数据流建模方法和IDEF1X数据建模方法； 掌握：Visio/EA等工具绘制模型图。 二、实验内容  1、请从下面的描述中找出绘制数据流图的四种成分并用Visio绘制数据流图。  某培训中心要研制一个计算机管理系统。它的业务是：将学员发来的信件收集分类后，按几种不同的情况处理。  （1) 如果是报名的，则将报名数据送给负责报名事务的职员，他们将查阅课程文件，检查该课程是否额满，然后在学生文件、课程文件上登记，并开出报告单交财务部门，财务人员开出发票给学生。  （2) 如果是想注销原来已选修的课程，则由注销人员在课程文件、学生文件和帐目文件上做相应的修改，并给学生注销单。  （3）如果是付款的，则由财务人员在帐目文件上登记，也给学生一张收费收据。  2、 有一简单选课系统，用文字描述如下，试用IDEF1X图和UML类图描述该系统的信息模型，并用Visio或EA绘制该IDEF1X图和UML类图。  1）基本描述：在该系统中，有学院、教师、课程、学生等实体，他们的属性分别是：  学院：学院编号、学院名称、地址、联系电话、院长等基本属性；  教师：教师编号、姓名、性别、年龄、职称、所在学院等属性；  课程：课程编号、课程名称、课程性质（必修/选修）、学分、开课学院等属性；  学生：学号、姓名、性别、年龄、入学时间、学院等属性。  教学班实体：教学班号、上课教师、课程、上课学期、上课时间、上课周次。  2）功能需求如下：  （1）能完成基本信息的维护：即各实体的基本信息的增、删、改、查。  （2）排课：为教师安排一学期所上的课程。一位教师在一学期可以上一门课或多门课，也可以不上课；一门课可以有多个教师上，但是不同的教师上的课应该属于不同的教学班。  （3）学生选课：学生根据教学要求进行选课。在学生选课之前检查该学生是否有选课资格（比如是否欠费、前期课程是否修完并通过）；一个学生可以选多门课、一门课可以被多个学生选修，但是一个学生不能选择同一门课的不同教学班；如果学生选了一门课的某个教学班后再选该门课的其他教学班系统应做出出错提示；统计已选教学班的学生人数；一个教学班的选课名额有限；学生选课后，如果发现选课不合理可以退选、重选；选课结束后应提供打印课程表的功能。  3、请用Visio或EA绘制如图2所示的用例图。 图2 用例图 三、实验方法  运用Visio2010工具进行数据流图、UML图和IDEF1X图设计。 四、实验步骤  1．打开Visio2010工具，选择【文件】→【新建】→【数据流】→【数据流图表】→【创建】，即可创建一个数据流图模板，之后在左侧即可选择适当图形进行数据流图绘制；  2．根据实验1要求，绘制数据流图，先按照各成分绘制，之后再将相关部分进行联系，并调整整体展示效果；  3．新建UML类图，按要求完成实验2-1；  4．新建IDEF1X图，按要求完成实验2-2；  5．新建用例图，按要求完成实验3。 五、实验结果  1．实验1数据流图如下所示：  2．实验2的UML图如下所示：  3．实验2的IDEF1X图如下所示：  4．实验3的用例图如下所示：  采购人员可以登录系统、形成订单、取消订单、填写订单、检查报价、提交需求表；  顾客可以形成订单；  部门主管可以签写报表；  财务人员可以查询财务数据、检查基本价格表、核实预售表、核实预售单；  开单员可以把自己所能查看到的信息打印出来，比如单据和提货单；  仓库员维护着整个仓库的入库出库状况，负责开出库单，审核入库单，打印导出数据等功能；  物流员可以把自己所能查看到的信息打印出来，比如加工单、运输单、入库单等； 六、实验结论  本次实验主要是对项目进行需求分析建模，有数据流图、UML图和IDEF1X图等，通过一系列建模从而对需求更加了解，也更加有利于项目计划开展。  实验结果的截图和文字分析见第五点。 七、实验小结  通过本次实验主要学会了绘制一些项目中常见的模型，比如数据流图、UML图、IDEF1X和用例图等，通过模型进而对需求进行抽象，得到自己所关心得部分，从而有利于项目的开发进行。  实验中遇到的主要问题是模型绘制的注意事项不是很了解，比如IDEF1X的实体如何分类、如何定义实体间的联系等，解决方式主要是通过对书本的反复阅读以及案例分析，其次就是一部分关系无法确定如何将在模型中展示，这个主要是与同学交流解决。  待改进的主要是实验2中有部分要求无法在规定的模型中展示，后续考虑通过其他模型进行展示，还有就是用例图中关系没有充分的完全展示出来，有待进一步优化。 ","date":"2019-08-04 18:43:07","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C2%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/:0:0","tags":["软件工程基础","实验2","需求分析"],"title":"软件工程基础 实验2《需求分析》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C2%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件项目可行性研究及项目计划的基本原理与方法，利用Visio等工具进行可行性研究和制定项目计划。通过对图书馆管理系统的基本流程进行描述举例。","date":"2019-08-04 18:02:04","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C1%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/","tags":["软件工程基础","实验一","可行性研究与项目计划"],"title":"软件工程基础 实验1《可行性研究与项目计划》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C1%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/"},{"categories":["软件工程"],"content":"本文内容主要是讲解软件项目可行性研究及项目计划的基本原理与方法，利用Visio等工具进行可行性研究和制定项目计划。通过对图书馆管理系统的基本流程进行描述举例。 版权声明：本文为博主原创文章，遵循 CC BY-NC-SA 4.0 版权协议，禁止商用，转载请附上原文出处链接和本声明。 实验1《可行性研究与项目计划》 一、实验目的 了解：软件项目可行性研究及项目计划的基本原理与方法； 掌握：Visio等工具进行可行性研究和制定项目计划。 二、实验内容  图书管管理系统更便于对图书进行分类和管理，对借阅者进行时间限定，使得借书的效益更高更安全。提高工作效益，便于操作，能有效地对数据进行更新、查询，并能在一定程度上实现了自动化。图书管管理系统的主要功能为：书目管理、借阅证管理、借还图书、查询、缴费。书目管理主要是针对管理员身份而言的（比如新增书目，删除书目等等）；借阅证管理分为五部分：注册、补发、挂失、暂停、注销；借还图书：借书、还书；查询：图书查询、借阅时间；缴费主要是计算超期罚款并交纳费用。  图书管管理系统的系统流程图如图1所示。 图1 系统流程图  试对系统进行可行性研究，用Visio绘制图书馆管理系统的系统流程图，同时制定系统的开发计划，用Gantt图和时间线图描述进度计划安排。  实验内容分点描述： 对图书馆管理系统进行分析，用Visio绘制图书馆管理系统的系统流程图； 制定图书馆管理系统的开发计划； 用Gantt图描述进度计划安排； 用时间线图描述项目进度开发计划。 三、实验方法 运行快速应用开发模型（RAD）对图书馆管理系统进行开发分析； 根据实验内容即项目需要对项目进行建模分析； 使用Visio工具对图书管理系统进行建立系统流程图、Gantt图、时间线图； 使用第3步绘制的各个模型对项目进行进一步的开发可行性分析和计划分析。 四、实验步骤 对图书馆管理系统进行开发可行性分析及需求分析，记录所有功能模块； 利用功能模块对系统进行总体系统流程图设计，即图书馆管理系统系统流程图； 2.1 利用Visio工具，选择【文件】→【新建】→【流程图】→【工作流程图】→【创建】，即可创建一个系统流程图模板； ​ 2.2 在左侧栏目选择【更多形状】→【流程图】→【基本流程图形状】，这样便可以在左下侧看到绘制系统流程图的许多基本形状； 2.3 根据【基本流程图形状】、【工作流程对象】和之前了解的系统功能需求，即可自由选择图形并加上文字形成系统流程图初稿； 2.4 对系统流程图加上箭头表明系统功能开发方向； 2.5 对系统流程图进行排版样式设计，命名自然，要有艺术性的美观。 对图书馆管理系统进行细分，分为学生模块和管理员模块，分别完成两个模块的系统流程图； 完成学生模块系统流程图，参考图书馆管理系统系统流程图设计（第2点）； 完成管理员模块系统流程图，参考图书馆管理系统系统流程图设计（第2点）； 对项目进行开发进度规划，完成Gantt图绘制； 6.1 利用Visio工具，选择【文件】→【新建】→【甘特图】→【甘特图】→【创建】，即可创建一个Gantt图模板； 6.2 根据选项设置人物数目、持续时间选项、时间刻度范围和时间单位； 6.3 设置任务名称、开始时间、完成时间、持续时间等； 6.4 Gantt图中的任务数目、时间等信息均可使用鼠标右键进行再调整； 6.5 设置Gantt图的标题，对Gantt图进行样式调整。 根据项目开发计划绘制的Gantt图，完成项目开发的时间线图绘制； 7.1 利用Visio工具，选择【文件】→【新建】→【日程表】→【日程表】→【创建】，即可创建一个时间线图模板，在模板左下侧有许多可使用的日程表形状； ​ 7.2 在左下侧先选择一个日程表形状，之后设置此日程表的时间段和刻度等信息； 7.3 从左下侧选择任意里程碑形状，拖入到绘图页； 7.4 在配置框中对该里程碑进行日期、时间、说明等信息设置； 7.5 在页面左下角选择间隔块推入到绘图页中； 7.6 在间隔块配置框中设置开始时间、结束时间和说明等信息； 7.7 选择左侧的【更多形状】→【日程安排】→【甘特图形状】→【标题】，对时间线图进行标题设置； 7.8 点击【日程表形状】，选择左下侧形状中【“今日”标志】，拖到绘图页中的今天； 7.9 调整时间线图的中里程碑等形状大小样式等。 根据实验成果，分析并得出结论，完成实验报告书写。 五、实验结果 绘制了图书馆管理系统系统流程图； 5-1图书馆管理系统流程图 5-2 图书馆管理系统流程图——学生模块 5-3 图书馆管理系统流程图——管理员模块 绘制了图书馆管理系统的Gantt图； 5-4 图书馆管理系统之Gantt图 绘制了图书馆管理系统开发计划的时间线图。 5-5 图书馆管理系统开发计划之时间线图 六、实验结论  本次实验主要是对图书馆管理系统进行开发计划分析，通过绘制模型进行更加高效开发，成果主要为第五点所示的图书馆管理系统流程图、Gantt图、时间线图。  通过对绘制的五个模型加以分析，更加确定了图书馆管理系统的开发可行性以及具体的开发流程。将项目开发中许多的不可预估的事情转化为了可预估事情，有利于项目的具体实施开展。 七、实验小结  通过本次实验，主要是学会了对于项目进行建模分析，比如系统流程图、Gantt图、时间线图等等，以各个模型为基础，进一步有利于项目的开发进行与实际落实。  在本次实验过程中，遇到的问题主要是对Visio工具的使用不太熟悉，有许多模型的各个组件不知如何设计，所以模型存在一定不足。  解决方式主要为利用老师上传的PPT、视频进行自主学习，或者通过谷歌进行搜索然后多次尝试解决、  实验的不足之处主要是各个模型可能不全面，缺少某个部件，还有就是部分设计可能未完全规划好。问题原因在于对Visio绘图工具的使用过少，后续将继续学习，加强锻炼，进而对各个模型进行完善。 ","date":"2019-08-04 18:02:04","objectID":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C1%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/:0:0","tags":["软件工程基础","实验一","可行性研究与项目计划"],"title":"软件工程基础 实验1《可行性研究与项目计划》","uri":"https://zz2summer.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80-%E5%AE%9E%E9%AA%8C1%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/"}]